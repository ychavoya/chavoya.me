export const PERSONAL_DESCRIPTION = `Yael Chavoya is a passionate Full-Stack Software Developer with a diverse set of skills and expertise and a drive to constantly improve who has developed and deployed mission-critical systems and strategic open source projects, mentored and collaborated with developers from across the globe.`;

export const CODE = `@Service class TicketUpdateHandler(ticketUpdateConsumer: TicketUpdateConsumer, private val objectMapper: ObjectMapper, private val logger: Logger) : WebSocketHandler { private val sessions: ArrayList<Pair<String, WebSocketSession>> = arrayListOf(); private val flux = Flux.create(ticketUpdateConsumer).share(); init { flux.doOnNext { logger.info("Ticket {} updated", it.ticketId) }.subscribe() }; override fun handle(session: WebSocketSession): Mono<Void> { val id = session.id; val input = session.receive().map { logger.info("Client $id requested updates for ticket \${it.payloadAsText}"); sessions.add(Pair(it.payloadAsText, session)) }.then().doFinally { logger.debug("Client $id closed connection"); sessions.removeIf { it.second.id == id } }; val output = session.send( flux.filter { update -> sessions.any { it.first == update.ticketId && it.second.id == id } }.map(objectMapper::writeValueAsString).map(session::textMessage)); return Mono.zip(input, output).then() } } @Component class JwtTokenProvider( credentialsProperties: CredentialsProperties, private val functionalUserProperties: FunctionalUserProperties ) { companion object { const val AUTHORITY_KEY = "rol" const val RESOURCE_ID_KEY = "rid" } private val secretKey: String = credentialsProperties.jwtSecret get() = Base64.getEncoder().encodeToString(field.encodeToByteArray()) fun createUserToken(authentication: Authentication): String { val claims = Jwts.claims().setSubject(authentication.name) claims[AUTHORITY_KEY] = authentication.authorities.stream() .map(GrantedAuthority::getAuthority) .collect(Collectors.joining(",")) return buildToken(claims) } fun createFunctionalToken(comensal: Comensal): String { val claims = Jwts.claims().setSubject(comensal.uuid) claims[AUTHORITY_KEY] = Roles.FUNCTIONAL claims[RESOURCE_ID_KEY] = comensal.resourceId return buildToken(claims) } private fun buildToken(claims: Claims): String { val ahora = Instant.now() val vencimiento = ahora.plus(4, ChronoUnit.HOURS) return Jwts.builder() .setClaims(claims) .setIssuedAt(Date.from(ahora)) .setExpiration(Date.from(vencimiento)) .signWith(SignatureAlgorithm.HS256, secretKey) .compact() } fun getAuthenticationFromToken(token: String): Authentication { val claims = Jwts.parser().setSigningKey(secretKey).parseClaimsJws(token).body val authorities = AuthorityUtils.commaSeparatedStringToAuthorityList(claims[AUTHORITY_KEY].toString()) val principal = if (claims.containsKey(RESOURCE_ID_KEY)) { Comensal(claims[RESOURCE_ID_KEY].toString(), functionalUserProperties, claims.subject) } else { User(claims.subject, "", authorities) } return UsernamePasswordAuthenticationToken(principal, token, authorities) } fun isTokenValid(token: String): Boolean { try { val claims = Jwts.parser().setSigningKey(secretKey).parseClaimsJws(token) return !claims.body.expiration.before(Date.from(Instant.now())) } catch (exception: JwtException) { throw ResponseStatusException(HttpStatus.UNAUTHORIZED, "Invalid or expired JWT", exception) } } }`;
